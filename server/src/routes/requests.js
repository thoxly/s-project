const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');

// CORS middleware –¥–ª—è —ç—Ç–æ–≥–æ —Ä–æ—É—Ç–µ—Ä–∞ (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞)
router.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With, Accept, Origin');
  res.header('Access-Control-Expose-Headers', 'Content-Type, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(204);
    return;
  }
  next();
});

// –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å, –µ—Å–ª–∏ MongoDB –ø–æ–¥–∫–ª—é—á–µ–Ω–∞
let SupportRequest;
try {
  SupportRequest = require('../models/SupportRequest');
} catch (error) {
  console.warn('‚ö†Ô∏è  SupportRequest model not available');
}

// Mock data for development (fallback)
const mockRequests = [
  {
    id: 1,
    title: '–ü—Ä–æ–±–ª–µ–º–∞ —Å –ø—Ä–∏–Ω—Ç–µ—Ä–æ–º',
    description: '–ü—Ä–∏–Ω—Ç–µ—Ä –≤ –æ—Ñ–∏—Å–µ –Ω–µ –ø–µ—á–∞—Ç–∞–µ—Ç',
    status: 'in_progress',
    priority: 'high',
    userId: 1,
    createdAt: '2024-01-15T10:30:00Z',
    updatedAt: '2024-01-15T14:20:00Z'
  },
  {
    id: 2,
    title: '–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è',
    description: '–ù—É–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å Adobe Photoshop',
    status: 'completed',
    priority: 'medium',
    userId: 2,
    createdAt: '2024-01-14T09:15:00Z',
    updatedAt: '2024-01-15T16:45:00Z'
  },
  {
    id: 3,
    title: '–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–æ—á—Ç—ã',
    description: '–ü–æ–º–æ—â—å —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–æ–π –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–æ–π –ø–æ—á—Ç—ã',
    status: 'pending',
    priority: 'low',
    userId: 3,
    createdAt: '2024-01-16T11:00:00Z',
    updatedAt: '2024-01-16T11:00:00Z'
  }
];

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ MongoDB
const isMongoConnected = () => {
  const readyState = mongoose.connection.readyState;
  const hasModel = !!SupportRequest;
  const connected = readyState === 1 && hasModel;
  
  if (!connected) {
    console.warn('‚ö†Ô∏è  isMongoConnected() returned false:', {
      readyState,
      readyStateText: readyState === 0 ? 'disconnected' : 
                      readyState === 1 ? 'connected' :
                      readyState === 2 ? 'connecting' :
                      readyState === 3 ? 'disconnecting' : 'unknown',
      hasModel,
      modelName: SupportRequest ? SupportRequest.modelName : 'undefined'
    });
  }
  
  return connected;
};

// Get all support requests (–∑–∞—è–≤–∫–∏ –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É)
router.get('/support', async (req, res) => {
  try {
    if (isMongoConnected()) {
      const requests = await SupportRequest.find()
        .sort({ createdAt: -1 })
        .lean();
      
      return res.json({
        success: true,
        data: requests,
        total: requests.length,
        message: "–ó–∞—è–≤–∫–∏ –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"
      });
    } else {
      // Fallback to mock data
      return res.json({
        success: true,
        data: [],
        total: 0,
        message: "MongoDB –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∂–∏–º –º–æ–∫–æ–≤"
      });
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞—è–≤–æ–∫:', error);
    return res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get support request by id_portal
router.get('/support/:idPortal', async (req, res) => {
  try {
    const { idPortal } = req.params;
    
    if (isMongoConnected()) {
      const request = await SupportRequest.findOne({ 'context.id_portal': idPortal }).lean();
      
      if (!request) {
        return res.status(404).json({
          success: false,
          error: '–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'
        });
      }
      
      return res.json({
        success: true,
        data: request
      });
    } else {
      return res.status(404).json({
        success: false,
        error: 'MongoDB –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞'
      });
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞—è–≤–∫–∏:', error);
    return res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Create new support request (–∑–∞—è–≤–∫–∞ –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É)
router.post('/support', async (req, res) => {
  try {
    const requestData = req.body;
    
    console.log('üì• POST /api/requests/support - –ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞—è–≤–∫–∏');
    console.log('üìã –¢–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞:', JSON.stringify(requestData, null, 2));
    console.log('üîå –°–æ—Å—Ç–æ—è–Ω–∏–µ MongoDB:', {
      readyState: mongoose.connection.readyState,
      isConnected: mongoose.connection.readyState === 1,
      hasModel: !!SupportRequest
    });
    
    const mongoConnected = isMongoConnected();
    console.log('‚úÖ isMongoConnected():', mongoConnected);
    
    if (!mongoConnected) {
      console.error('‚ùå MongoDB –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞! –°–æ—Å—Ç–æ—è–Ω–∏–µ:', {
        readyState: mongoose.connection.readyState,
        readyStateText: mongoose.connection.readyState === 0 ? 'disconnected' : 
                        mongoose.connection.readyState === 1 ? 'connected' :
                        mongoose.connection.readyState === 2 ? 'connecting' :
                        mongoose.connection.readyState === 3 ? 'disconnecting' : 'unknown',
        hasModel: !!SupportRequest
      });
      return res.status(503).json({
        success: false,
        error: 'MongoDB –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞. –ó–∞—è–≤–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.',
        debug: {
          readyState: mongoose.connection.readyState,
          hasModel: !!SupportRequest
        }
      });
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
    if (!requestData.context || !requestData.context.id_portal || !requestData.context.application_text) {
      console.error('‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è:', {
        hasContext: !!requestData.context,
        hasIdPortal: !!(requestData.context && requestData.context.id_portal),
        hasApplicationText: !!(requestData.context && requestData.context.application_text)
      });
      return res.status(400).json({
        success: false,
        error: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è: context.id_portal –∏ context.application_text'
      });
    }
    
    console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∑–∞—è–≤–∫–∏ —Å id_portal:', requestData.context.id_portal);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –∑–∞—è–≤–∫–∞ —Å —Ç–∞–∫–∏–º id_portal
    const existingRequest = await SupportRequest.findOne({ 
      'context.id_portal': requestData.context.id_portal 
    });
    
    if (existingRequest) {
      console.warn('‚ö†Ô∏è –ó–∞—è–≤–∫–∞ —Å —Ç–∞–∫–∏–º id_portal —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç:', requestData.context.id_portal);
      return res.status(409).json({
        success: false,
        error: '–ó–∞—è–≤–∫–∞ —Å —Ç–∞–∫–∏–º id_portal —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'
      });
    }
    
    console.log('‚ú® –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∑–∞—è–≤–∫–∏...');
    
    // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ context —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π solution_description
    const contextData = { ...requestData.context };
    // –ï—Å–ª–∏ solution_description —Ä–∞–≤–µ–Ω null, —É–¥–∞–ª—è–µ–º –µ–≥–æ –∏–∑ context
    if (contextData.solution_description === null || contextData.solution_description === undefined) {
      delete contextData.solution_description;
    }
    
    const newRequest = new SupportRequest({
      context: contextData,
      sentAt: requestData.sentAt ? new Date(requestData.sentAt) : new Date(),
      currentStatus: requestData.currentStatus || '–ù–æ–≤–∞—è',
      userId: requestData.userId || null
    });
    
    console.log('üíæ –ü–æ–ø—ã—Ç–∫–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∑–∞—è–≤–∫—É –≤ –ë–î...');
    const savedRequest = await newRequest.save();
    
    console.log('‚úÖ –ó–∞—è–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –ë–î:', {
      id: savedRequest._id,
      id_portal: savedRequest.context.id_portal,
      status: savedRequest.currentStatus
    });
    
    return res.status(201).json({
      success: true,
      data: savedRequest,
      message: '–ó–∞—è–≤–∫–∞ –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞'
    });
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞—è–≤–∫–∏:', error);
    console.error('üìä –î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:', {
      name: error.name,
      message: error.message,
      stack: error.stack,
      code: error.code,
      errors: error.errors
    });
    return res.status(500).json({
      success: false,
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? {
        name: error.name,
        code: error.code,
        errors: error.errors
      } : undefined
    });
  }
});

// Update support request status
router.patch('/support/:idPortal/status', async (req, res) => {
  try {
    const { idPortal } = req.params;
    const { currentStatus } = req.body;
    
    if (!currentStatus) {
      return res.status(400).json({
        success: false,
        error: '–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–ª–µ currentStatus'
      });
    }
    
    if (isMongoConnected()) {
      const request = await SupportRequest.findOneAndUpdate(
        { 'context.id_portal': idPortal },
        { 
          currentStatus: currentStatus,
          updatedAt: new Date()
        },
        { new: true, runValidators: true }
      );
      
      if (!request) {
        return res.status(404).json({
          success: false,
          error: '–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'
        });
      }
      
      return res.json({
        success: true,
        data: request,
        message: '–°—Ç–∞—Ç—É—Å –∑–∞—è–≤–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω'
      });
    } else {
      return res.status(503).json({
        success: false,
        error: 'MongoDB –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞'
      });
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞:', error);
    return res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Update support request (–ø–æ–ª–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ)
router.put('/support/:idPortal', async (req, res) => {
  try {
    const { idPortal } = req.params;
    const updateData = req.body;
    
    if (isMongoConnected()) {
      const request = await SupportRequest.findOneAndUpdate(
        { 'context.id_portal': idPortal },
        { 
          ...updateData,
          updatedAt: new Date()
        },
        { new: true, runValidators: true }
      );
      
      if (!request) {
        return res.status(404).json({
          success: false,
          error: '–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'
        });
      }
      
      return res.json({
        success: true,
        data: request,
        message: '–ó–∞—è–≤–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞'
      });
    } else {
      return res.status(503).json({
        success: false,
        error: 'MongoDB –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞'
      });
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∑–∞—è–≤–∫–∏:', error);
    return res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get requests by user ID (legacy endpoint)
router.get('/user/:userId', (req, res) => {
  const { userId } = req.params;
  const userRequests = mockRequests.filter(req => req.userId === parseInt(userId));
  
  res.json({
    success: true,
    data: userRequests,
    total: userRequests.length
  });
});

// Get all requests (legacy endpoint)
router.get('/', (req, res) => {
  res.json({
    success: true,
    data: mockRequests,
    total: mockRequests.length,
    message: "üî• Hot reload is working! Server restarted automatically."
  });
});

// Get single request (legacy endpoint)
router.get('/:id', (req, res) => {
  const { id } = req.params;
  const request = mockRequests.find(req => req.id === parseInt(id));
  
  if (!request) {
    return res.status(404).json({
      success: false,
      error: 'Request not found'
    });
  }
  
  res.json({
    success: true,
    data: request
  });
});

// Create new request (legacy endpoint)
router.post('/', (req, res) => {
  const { title, description, priority, userId } = req.body;
  
  const newRequest = {
    id: mockRequests.length + 1,
    title,
    description,
    status: 'pending',
    priority: priority || 'medium',
    userId: userId || 1,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
  
  mockRequests.push(newRequest);
  
  res.status(201).json({
    success: true,
    data: newRequest,
    message: 'Request created successfully'
  });
});

// Update request status (legacy endpoint)
router.patch('/:id/status', (req, res) => {
  const { id } = req.params;
  const { status } = req.body;
  
  const request = mockRequests.find(req => req.id === parseInt(id));
  
  if (!request) {
    return res.status(404).json({
      success: false,
      error: 'Request not found'
    });
  }
  
  request.status = status;
  request.updatedAt = new Date().toISOString();
  
  res.json({
    success: true,
    data: request,
    message: 'Request status updated'
  });
});

module.exports = router;
